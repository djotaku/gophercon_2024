Who Tests the Tests?

go test -cover # unit tests
go build -cover # intergration tests

A metric that becomes a goal stops bein ga good metric  - basically you end up gamifying things and people stop when they reach the goal.

Also, people may end up testing things they don't need to test like the main function so they can reach the target for coverage

Example of a faked test that will never fail and make 100% code coverage

Testing mutants - if the fest fails the mutatn was killed. If it passes the mutant survived. Measure the quality of the test suite by how many mutants it kills

-------------

Interface internals

Interface variables bridge the gap betweeen static and dynamic worlds

Interfaces are just 2 word structs

-----------

Building a High-Performance Concurrent Map in Go

Why do we need a concurrent safe map? if use go routines to read/write a bult-in map at the same time, it will panic

How to build a concurrent safe map in go?

sync.Map - a concurrent-safe map provided by the stdlib

map[K]V + sync.RWMutex

sync.map takes twice as long to do its operations vs the mutex

Reason that it's slower is because it was designed to solve cache contention; (it IS faster for the load-only case)

If you're usimg map as a concurrent cache, the performance will not be good enough

RWMAP - only one write op at a time, but multiple reads allowed concurrently

    - Write ends up blocking the entire map

One solution is a shared map. Each key is its own map (at least that's how it seems from the image on the slide)

How many maps needed to create the shared map?
    - X CPU cores -> X read-write mutex maps in the shared map
    - hash function determins which map a key should go to

In the example benchmark, the shared map is twice as fast as the RWMap; However, it does require more memory

Eventually they end up using a linked list to make things even more efficient.

--------------------

The Go Cryptography State of the Union

Good thing is that post-quantum crypto doesn't need quantum computers to implement

Bad thing - untested compared to standard crypto; larger 1kb per exchange

For Go they have writen from scratch to match the spec, not the example implementation (good because ref implementation was found to have vulns that the Go implementation dind't have)

crypto/internal/mlkem768

in go 1.23 tls configuration is much easier

version in go.mod affects how the tls stuff will work

before 1.22 no secure way to use math/rand

the /x/ part of the lib will be deprecated beause it causes confusion as to what is officially supported

"No is temporary, yes is forever" - Solomon Hykes on the Go API promise

They are going to add FIPS 140 proper support.


------
Advanced Code Instrumentation Techniques for High-Performance Trading Systems

when you measure system performance, you're adding overhead to the system

when they measured system, 35% of CPU was dedicated to the performance monitoring

trading system needs ultra-low latency with high throughput

Solution: MetricHandle - type MetricHandle uint32

The application responsible for maintaining association between metric and what it's measuring


--------

Digital Audio from Scratch

github.com/200sc/daw

demo



------

Lightning Talks

------

A 10-Year Retrospective on Building an Infrastructure Start-up in Go

------

Processing Millions of Events Per Second Reliably Using Generics

-----

Building a Self-Regulating Pressure Relief Mechanism in Go

-----

Go in the Smallest of Places <- unale to attend due to needing ot get to flight back home. Look for it online.


