keynote - history about Go - Ron Evans

"Go not for embedded programming" - but speaker created Gobot to use Go to program a drone

"Everyone knows you have to use Python or C++ for computer vision" - speaker ignores this and creates a Go library for OpenCV

YOLO is a computer vision tracking model

"Everyone knows you need to use C or C++ for microcontrollers" - but the speaker and another person create TinyGo

LLM demo with talking heads.
    - LangChainGo
    - Dollheads will use TinyGo to contorll them.


Instead of AI (artificiatl intel), AI - amplification intelligence

-----

Build a Glamorous Habit Tracker using Charm CLII

Ideal Habit Tracker?

    - speaker started playing clarinet and needed to be consistent to learn how to play well.Wanted to track how much they were playing during the week to be able to tell their instructor.
    - They have a struct to hold a Habit. (ID, Name, Desc, Target, TicksCount)
    - They wanted to design it on CLI vs a phone app
    - TUI constraints
        - display strings
        - print logs in a file
        - handle errors properly

What is Charm_?
    - Charm_ (underscore is part of the name)
        - libs`
            - bubbles
            - bubble tea
            - lip gloss
            - glamour
    - Bubble Tea - based on Elm Architecture. MVU (Model, view, Update)
    - (see slides for the models involved)
    -

Demo


Charm Cheatsheet

-------------

Exploring Go Compiler: Adding a "four" loop

(see talk - lots of code and flow diagrams)

-------------


Advanced Generics Patterns

@merovius@chaos.social

according to reddit and some blog posts - it seems most folks are not using Generics since their addition in 1.18

The Basics

type Slice[E any] []E

A type parameter can be inferrred if and only if it appears in an argument

Corollary: If you want a type parameter to be inferrable.... (see slide)

Constraints

How can you stringify a generic type? One way is to list all the potential types for your Generic (making sure these are all types that can be stringified)

Or you can have a method constraint.

But you can't do both types of things (method constraint and listing types)

Or you don't have constraints, but you accept a function.

Overall, the thesis of the talk is that we need to "break" Generics. What they mean is that by pushing the boundaries of what can be done with generics we determine how the standard library should evolve to allow for an increased usage of generics.

----------------

Building a Deterministic Interpreter in Go: Readability vs Performance


From Gno.land

created CosmosSDK - most popular SDK for Go blockchain development

They came up with GnoVM to allows seamless interoperability of untrusted programs

gRPC can somewhat solve the problem, but less elegantly than what Gno.Land proposes

So they use smart contracts - which allow untrusted programs to interact

Go typically not used for smart contract programming. (Even if it is often used for programming the underlying blockchain)

WASM allows for running unsafe code like containers, but less overhead

Reason to now simply use WASM is that it relys on the actor model (message passing)

Gno.Land's solution to the WASM issue is the GnoVM. It interprets the Go language.

The VM is written in Go.

All changes are tracked during execution and persisted (saved to disk) at the end of hte user's program

Lessons Learned

     - Primitive types stored as interface vars allocate pointers under the hood (starting with Go 1.4)
     - Avoid switching on interfaces when type-switches will do. Comparing 2 interface values is slow.
     - Scope != Allocation; ie for loops and GOTO statements
     - Go reflection is limited. Cannot create named types, recursive types, or interfaces


Future work

    - Upgrading the logic will be difficult
    - Updating a function or metho w/ same sig is OK
    - Appending fields to a struct will break old logic
    - Appending methods to declared types will break old logic that uses type checks
    - intra-transaction garbage collection. It's currently a little more complex. Gno doens't know when Go has garbage collected an object. When Gno memory limit is reached it will re-count everything reachable from the Gno VM
    - they have some ways to fix these issues.


